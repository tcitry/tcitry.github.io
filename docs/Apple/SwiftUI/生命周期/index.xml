<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>生命周期 on LYon's Blog</title><link>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><description>Recent content in 生命周期 on LYon's Blog</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>onReceive</title><link>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/onReceive/</link><pubDate>Sun, 23 Feb 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/onReceive/</guid><description>&lt;p>让我们从 &lt;strong>技术原理&lt;/strong>、&lt;strong>核心功能&lt;/strong>、&lt;strong>实际案例&lt;/strong> 和 &lt;strong>体系结构&lt;/strong> 四个维度，深入探讨 SwiftUI 中 &lt;code>onReceive&lt;/code> 的完整使用体系。&lt;/p>
&lt;hr>
&lt;h2 id="一技术原理combine-与-swiftui-的桥梁">一、技术原理：Combine 与 SwiftUI 的桥梁&lt;a class="anchor" href="#%e4%b8%80%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86combine-%e4%b8%8e-swiftui-%e7%9a%84%e6%a1%a5%e6%a2%81">#&lt;/a>&lt;/h2>
&lt;h3 id="1-publisher-与-subscriber-模型">1. Publisher 与 Subscriber 模型&lt;a class="anchor" href="#1-publisher-%e4%b8%8e-subscriber-%e6%a8%a1%e5%9e%8b">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Publisher&lt;/strong>：数据源的抽象，可以发送值（&lt;code>Output&lt;/code>）或错误（&lt;code>Failure&lt;/code>）。&lt;/li>
&lt;li>&lt;strong>Subscriber&lt;/strong>：接收并处理来自 Publisher 的数据。&lt;/li>
&lt;li>&lt;strong>Operator&lt;/strong>：在 Publisher 和 Subscriber 之间转换或处理数据流。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>onReceive&lt;/code> 是 SwiftUI 提供的一个 &lt;strong>Subscriber 封装&lt;/strong>，专门用于在视图中订阅 Publisher，并将接收到的值转换为视图的副作用（如更新状态）。&lt;/p></description></item><item><title>scenePhase</title><link>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/scenePhase/</link><pubDate>Tue, 04 Feb 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/scenePhase/</guid><description>&lt;p>在 SwiftUI 中，&lt;code>ScenePhase&lt;/code> 是一个枚举类型，用于表示应用程序场景（Scene）的生命周期状态。通过监听 &lt;code>ScenePhase&lt;/code>，你可以根据场景的状态（如活跃、后台、挂起等）执行相应的操作，例如保存数据、暂停任务或更新 UI。&lt;/p></description></item><item><title>onDelete</title><link>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/onDelete/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/onDelete/</guid><description>&lt;p>在 SwiftUI 中，&lt;code>onDelete&lt;/code> 通常与列表（&lt;code>List&lt;/code>）结合使用，用来支持从数据源中移除项的功能。正确的使用层级是&lt;strong>在列表的子视图中绑定 &lt;code>ForEach&lt;/code> 或其他类型的数据管理容器&lt;/strong>，确保操作仅适用于具体的数据项，同时也能准确执行删除操作。&lt;/p></description></item><item><title>onSubmit</title><link>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/onSubmit/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/onSubmit/</guid><description>&lt;p>在 SwiftUI 中，&lt;code>onChange&lt;/code> 和 &lt;code>onSubmit&lt;/code> 是两种用于响应用户交互的修饰符。它们的作用是监听特定事件或动作并触发开发者定义的逻辑。让我们详细讲解这两种方法以及类似的其他方法。&lt;/p></description></item><item><title> 生命周期 onAppear 等</title><link>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/life-cycle-method/</link><pubDate>Mon, 30 Dec 2024 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Apple/SwiftUI/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/life-cycle-method/</guid><description>&lt;p>在 SwiftUI 中，生命周期管理是一项重要功能，开发者需要在某个视图的特定阶段执行代码逻辑，例如当视图出现、消失、弹出回到页面时响应事件。除了 &lt;code>onAppear&lt;/code> 和 &lt;code>onDisappear&lt;/code> 之外，SwiftUI 提供了一些其他的生命周期管理相关修饰符和工具。&lt;/p></description></item></channel></rss>