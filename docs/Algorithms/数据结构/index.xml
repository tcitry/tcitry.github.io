<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LYon's Blog</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><description>Recent content on LYon's Blog</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>链表（Linked list）</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</link><pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</guid><description>&lt;h2 id="基本概念">基本概念&lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#&lt;/a>&lt;/h2>
&lt;h3 id="单向链表">单向链表&lt;a class="anchor" href="#%e5%8d%95%e5%90%91%e9%93%be%e8%a1%a8">#&lt;/a>&lt;/h3>
&lt;h4 id="javascript">JavaScript&lt;a class="anchor" href="#javascript">#&lt;/a>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">function&lt;/span> &lt;span style="color:#aa89ea">ListNode&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">val&lt;/span>&lt;span style="color:#abb2bf">,&lt;/span> &lt;span style="color:#aa89ea">next&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span> &lt;span style="color:#abb2bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#76a9f9">this&lt;/span>&lt;span style="color:#abb2bf">.&lt;/span>&lt;span style="color:#aa89ea">val&lt;/span> &lt;span style="color:#54b1c7">=&lt;/span> &lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">val&lt;/span> &lt;span style="color:#54b1c7">===&lt;/span> &lt;span style="color:#e5c07b">undefined&lt;/span> &lt;span style="color:#54b1c7">?&lt;/span> &lt;span style="color:#d19a66">0&lt;/span> &lt;span style="color:#54b1c7">:&lt;/span> &lt;span style="color:#aa89ea">val&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#76a9f9">this&lt;/span>&lt;span style="color:#abb2bf">.&lt;/span>&lt;span style="color:#aa89ea">next&lt;/span> &lt;span style="color:#54b1c7">=&lt;/span> &lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">next&lt;/span> &lt;span style="color:#54b1c7">===&lt;/span> &lt;span style="color:#e5c07b">undefined&lt;/span> &lt;span style="color:#54b1c7">?&lt;/span> &lt;span style="color:#e5c07b">null&lt;/span> &lt;span style="color:#54b1c7">:&lt;/span> &lt;span style="color:#aa89ea">next&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#abb2bf">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="golang">Golang&lt;a class="anchor" href="#golang">#&lt;/a>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">type&lt;/span> &lt;span style="color:#aa89ea">ListNode&lt;/span> &lt;span style="color:#76a9f9">struct&lt;/span> &lt;span style="color:#abb2bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#aa89ea">Val&lt;/span> &lt;span style="color:#e5c07b">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#aa89ea">Next&lt;/span> &lt;span style="color:#54b1c7">*&lt;/span>&lt;span style="color:#aa89ea">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#abb2bf">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="双向链表">双向链表&lt;a class="anchor" href="#%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8">#&lt;/a>&lt;/h3>
&lt;p>双向链表在单向链表节点的基础上增加了指向前一个节点的指针，这样一来，既可以从头节点开始从前往后遍历到尾节点，也可以从尾节点开始从后往前遍历到头节点。&lt;/p></description></item><item><title>数组（Array）</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/</guid><description>&lt;h2 id="一维数组">一维数组&lt;a class="anchor" href="#%e4%b8%80%e7%bb%b4%e6%95%b0%e7%bb%84">#&lt;/a>&lt;/h2>
&lt;p>数组常被用来当做栈、堆和队列的容器，除此之外，大多是单纯只涉及数组的题目。&lt;/p>
&lt;p>特点：&lt;/p>
&lt;ol>
&lt;li>支持下标&lt;/li>
&lt;li>支持切片&lt;/li>
&lt;li>有固定长度或可变长度&lt;/li>
&lt;/ol>
&lt;h2 id="应用场景">应用场景&lt;a class="anchor" href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af">#&lt;/a>&lt;/h2>
&lt;p>数组结构很简单，但是出的题涉及的算法类型比较多，比如排序、二分法、双指针、滑动窗口，还会有一些是动态规划。&lt;/p></description></item><item><title>字符串（String）</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>&lt;p>字符串本身的数据结构并不复杂，同数组非常类似，没啥特别需要介绍的，就是题一般都不简单。&lt;/p>
&lt;p>做题需要考虑：&lt;/p>
&lt;ul>
&lt;li>有的字符串一定是 26 个字母，有的可能会包含空格。&lt;/li>
&lt;/ul>
&lt;h2 id="注意事项">注意事项&lt;a class="anchor" href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">#&lt;/a>&lt;/h2>
&lt;h3 id="golang">Golang&lt;a class="anchor" href="#golang">#&lt;/a>&lt;/h3>
&lt;p>注意：Go 的 for 循环得到的是 rune 类型的字符，需要进行转换。&lt;/p></description></item><item><title>队列（Queue）</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</guid><description>&lt;h2 id="普通队列">普通队列&lt;a class="anchor" href="#%e6%99%ae%e9%80%9a%e9%98%9f%e5%88%97">#&lt;/a>&lt;/h2>
&lt;p>队列的特点就是先进先出，后进后出。可以使用数组、链表实现队列。&lt;/p>
&lt;h3 id="队列的操作">队列的操作&lt;a class="anchor" href="#%e9%98%9f%e5%88%97%e7%9a%84%e6%93%8d%e4%bd%9c">#&lt;/a>&lt;/h3>
&lt;p>&lt;strong>插入元素&lt;/strong>（add）一般指在队列首部插入元素。&lt;/p>
&lt;p>&lt;strong>删除元素&lt;/strong>（remove）指删除队列末尾的元素。&lt;/p></description></item><item><title>栈（Stack）</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</guid><description>&lt;h2 id="基础知识">基础知识&lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86">#&lt;/a>&lt;/h2>
&lt;p>栈是一种常用的数据结构，它最大的特点是“后入先出”，即后进入栈中的元素最先出来，为了确保“后入先出”（LIFO）的顺序，栈的插入（push）和删除（pop）操作都发生在栈顶。&lt;/p></description></item><item><title>哈希表（Hash Table）</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</guid><description>&lt;h2 id="基础概念">基础概念&lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5">#&lt;/a>&lt;/h2>
&lt;p>哈希表是一种常见的数据结构，也叫散列表。哈希表最大的优点是高效，在哈希表中插入、删除或查找一个元素都只需要 O(1) 的时间。&lt;/p>
&lt;p>因此，哈希表经常被用来优化时间效率。除了专门考散列表的题，也经常作为辅助计算的数据结构，很多时候都可以考虑是否需要借助散列表解决。比如用来记录字符串中字母出现的次数、字符串中字符出现的位置等信息。&lt;/p></description></item><item><title>二叉树（Binary Tree）</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>&lt;h2 id="基本概念">基本概念&lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#&lt;/a>&lt;/h2>
&lt;h3 id="父节点子节点叶子节点">父节点，子节点，叶子节点&lt;a class="anchor" href="#%e7%88%b6%e8%8a%82%e7%82%b9%e5%ad%90%e8%8a%82%e7%82%b9%e5%8f%b6%e5%ad%90%e8%8a%82%e7%82%b9">#&lt;/a>&lt;/h3>
&lt;p>叶子节点： 一棵树当中没有子结点的结点称为叶子结点。&lt;/p>
&lt;h3 id="高度和深度">高度和深度&lt;a class="anchor" href="#%e9%ab%98%e5%ba%a6%e5%92%8c%e6%b7%b1%e5%ba%a6">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>树的高度：节点到叶子节点的最大值就是其高度。&lt;/li>
&lt;li>树的深度：高度和深度是相反的，高度是从下往上数，深度是从上往下。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意：&lt;/strong> 一般默认是把根节点的深度设为 1，把子节点的高度设为 1，比如 &lt;a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度&lt;/a>。在面试的时候最好要确认一下。&lt;/p></description></item><item><title>堆（Heap）</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</link><pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</guid><description>&lt;h2 id="介绍">介绍&lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#&lt;/a>&lt;/h2>
&lt;p>堆（heap）分为最大堆（大根堆/大顶堆）和最小堆（小根堆/小顶堆），通常用&lt;strong>完全二叉树&lt;/strong>实现，完全二叉树又可以用&lt;a href="https://yindongliang.com/docs/Algorithms/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e6%95%b0%e7%bb%84">数组&lt;/a>实现，故堆通常以数组形式进行存储，而非二叉树的链式存储。常见的堆有&lt;strong>二叉堆&lt;/strong>、&lt;strong>裴波那契堆&lt;/strong>等，通常也用堆来实现优先队列（Priority Queue）。&lt;/p>
&lt;h2 id="堆的特点">堆的特点&lt;a class="anchor" href="#%e5%a0%86%e7%9a%84%e7%89%b9%e7%82%b9">#&lt;/a>&lt;/h2>
&lt;p>堆属性非常有用，因为堆常常被当做优先队列使用，因为可以快速地访问到“最重要”的元素。&lt;/p></description></item><item><title>前缀树（Trie）</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%8D%E7%BC%80%E6%A0%91/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%8D%E7%BC%80%E6%A0%91/</guid><description>&lt;p>Trie 又称前缀树、字典树、单词查找树，是一种二叉树衍生出来的多叉树，通常用来保存字符串，它的节点和字符串的字符对应，而路径和字符串对应，主要应用场景是处理字符串前缀相关的操作。&lt;/p></description></item><item><title>红黑树</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/</link><pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid><description>&lt;p>红黑树也是一种&lt;strong>自平衡二叉搜索树&lt;/strong>，但不同的是，红黑树在每一个结点上增加了一个存储位来表示结点的颜色，可以是 &lt;code>Red&lt;/code> 或 &lt;code>Black&lt;/code>，通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出 2 倍，因而是近似于平衡的。红黑树的应用非常广，比如 epoll，研究相关底层原理时最好提前了解一下。&lt;/p></description></item><item><title>B 树</title><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B-tree/</link><pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B-tree/</guid><description>&lt;p>B 树是为磁盘或其他直接存取的辅助存储设备而设计的一种&lt;strong>平衡搜索树&lt;/strong>。B 树类似于红黑树，但它们在降低磁盘 I/O 操作数方面要更好一点，比如很多数据库都使用 B 树或 B 树的变种来存储信息。&lt;/p></description></item><item><title/><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E9%A1%B9%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E9%A1%B9%E6%A0%91/</guid><description/></item><item><title/><link>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%96%90%E6%B3%A2%E9%82%A3%E5%88%87%E5%A0%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%96%90%E6%B3%A2%E9%82%A3%E5%88%87%E5%A0%86/</guid><description/></item></channel></rss>