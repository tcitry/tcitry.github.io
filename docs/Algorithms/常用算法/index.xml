<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>常用算法 on LYon's Blog</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</link><description>Recent content in 常用算法 on LYon's Blog</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>递归</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/recursion/</link><pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/recursion/</guid><description>&lt;h2 id="建立思维">建立思维&lt;a class="anchor" href="#%e5%bb%ba%e7%ab%8b%e6%80%9d%e7%bb%b4">#&lt;/a>&lt;/h2>
&lt;p>理解递归的关键首先还是弄清楚二叉树的先序遍历、中序遍历和后序遍历的递归实现。任何递归可以说都处在这个模型中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">void&lt;/span> &lt;span style="color:#aa89ea">traverse&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">TreeNode&lt;/span> &lt;span style="color:#aa89ea">root&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span> &lt;span style="color:#abb2bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#76a9f9">if&lt;/span> &lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">root&lt;/span> &lt;span style="color:#54b1c7">==&lt;/span> &lt;span style="color:#e5c07b">null&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span> &lt;span style="color:#abb2bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#76a9f9">return&lt;/span>&lt;span style="color:#abb2bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#abb2bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8a93a5;font-style:italic">// 前序位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8a93a5;font-style:italic">&lt;/span> &lt;span style="color:#aa89ea">traverse&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">root&lt;/span>&lt;span style="color:#abb2bf">.&lt;/span>&lt;span style="color:#aa89ea">left&lt;/span>&lt;span style="color:#abb2bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8a93a5;font-style:italic">// 中序位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8a93a5;font-style:italic">&lt;/span> &lt;span style="color:#aa89ea">traverse&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">root&lt;/span>&lt;span style="color:#abb2bf">.&lt;/span>&lt;span style="color:#aa89ea">right&lt;/span>&lt;span style="color:#abb2bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8a93a5;font-style:italic">// 后序位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8a93a5;font-style:italic">&lt;/span>&lt;span style="color:#abb2bf">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果面试官明确要求不使用递归，那一般就是使用后进先出的栈来代替递归实现，可以参考 &lt;a href="https://yindongliang.com/docs/Algorithms/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e4%ba%8c%e5%8f%89%e6%a0%91">二叉树专题&lt;/a> 中遍历二叉树的非递归实现。&lt;/p></description></item><item><title>贪心算法</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 25 Jun 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid><description>&lt;p>贪心算法是一种在每一步选择中都采取当前状态下最优（即最有利）的选择，从而希望导致结果是全局最优的算法策略。&lt;/p>
&lt;p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的&lt;strong>贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。&lt;/strong>&lt;/p></description></item><item><title>滑动窗口</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link><pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid><description>&lt;p>滑动窗口也是一种双指针算法，但是滑动窗口特别强调窗口向一个方向滑动，看起来简单，但是却属于最难的一种双指针技巧，力扣上的题一般都是中等或困难难度。首要问题是识别什么样的问题需要滑动窗口解决，最常见的题型：子串问题。&lt;/p></description></item><item><title>动态规划</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>&lt;h2 id="介绍">介绍&lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#&lt;/a>&lt;/h2>
&lt;p>动态规划（Dynamic Programming，简称DP）常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。&lt;/p></description></item><item><title>双指针</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/</guid><description>&lt;p>双指针有时也叫滑动窗口，如果一定要和滑动窗口区别，那就是滑动窗口的窗口一般是向一个方向滑动，而双指针一般强调左右两个指针。除此之外，可能还会单独强调快慢指针，快慢指针也是一种双指针，但是两个指针的运动速度是不一样的，一快一慢。&lt;/p></description></item><item><title>二分查找</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>&lt;p>二分查找利用&lt;strong>已经排好序&lt;/strong>的数组，每次查找可以将查找范围减半，查找范围内只剩一个数据时查找结束。&lt;/p>
&lt;h2 id="代码模板">代码模板&lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81%e6%a8%a1%e6%9d%bf">#&lt;/a>&lt;/h2>
&lt;p>简单题的模板几乎都是统一的，根据题目的条件再灵活调整就可以了，比如 &lt;a href="https://leetcode.cn/problems/binary-search/">704. 二分查找&lt;/a>。&lt;/p></description></item><item><title>排序</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/sorting/</link><pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/sorting/</guid><description>&lt;p>排序是非常基础、重要的算法，它将若干数据依照特定的顺序进行排列。如果排序的对象是数值，那么按数值递增或递减的顺序进行排序；如果排序的对象是字符串，那么按照字典顺序进行排序。由于数据排序之后能够利用二分查找算法提高查找的效率，因此很多数据都是排序之后再存储的。&lt;/p></description></item><item><title>BFS 和 DFS</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/BFS-%E5%92%8C-DFS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/BFS-%E5%92%8C-DFS/</guid><description>&lt;p>参考 &lt;a href="https://yindongliang.com/docs/Algorithms/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e4%ba%8c%e5%8f%89%e6%a0%91">二叉树&lt;/a>&lt;/p>
&lt;p>广度优先算法（BFS）&lt;/p>
&lt;p>深度优先算法（DFS）&lt;/p></description></item><item><title>分治策略</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</guid><description>&lt;p>快速排序&lt;/p>
&lt;p>归并排序&lt;/p></description></item><item><title>回溯法</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95/</guid><description/></item><item><title>前缀和</title><link>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Algorithms/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/</guid><description>&lt;p>前缀和指一个数组的某下标之前的所有数组元素的和（包含其自身）。前缀和分为一维前缀和，以及二维前缀和。前缀和是一种重要的预处理，能够降低算法的时间复杂度。&lt;/p></description></item></channel></rss>