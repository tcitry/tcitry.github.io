<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码分析 on LYon's Blog</title><link>https://yindongliang.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><description>Recent content in 源码分析 on LYon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 18 Oct 2025 13:05:57 +0800</lastBuildDate><atom:link href="https://yindongliang.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>深入了解 Redis 的各种数据结构</title><link>https://yindongliang.com/posts/deep-in-redis-data-structure/</link><pubDate>Fri, 19 Aug 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/deep-in-redis-data-structure/</guid><description>&lt;p>最近面试中发现我比较薄弱的地方还是在 Redis，很多数据结构对应的底层的原理不知道，于是来看看相关资料和&lt;a href="https://github.com/redis/redis">源码&lt;/a>，工作中没有这么深入研究过，惭愧了。&lt;/p>
&lt;h2 id="string">String&lt;a class="anchor" href="#string">#&lt;/a>&lt;/h2>
&lt;h3 id="使用方法">使用方法&lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95">#&lt;/a>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; &lt;span style="color:#e5c07b">set&lt;/span> key value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; &lt;span style="color:#e5c07b">set&lt;/span> number &lt;span style="color:#d19a66">10086&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; &lt;span style="color:#e5c07b">set&lt;/span> title &lt;span style="color:#63c381">&amp;#34;hello redis&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; get key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#63c381">&amp;#34;value&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; get number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#63c381">&amp;#34;10086&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; get title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#63c381">&amp;#34;hello redis&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="底层结构">底层结构&lt;a class="anchor" href="#%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84">#&lt;/a>&lt;/h3>
&lt;p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串），C 语言内置的 int 就不用介绍了，下面详细说一下 SDS。&lt;/p></description></item><item><title>Go 语言的 MPG 并发调度模型</title><link>https://yindongliang.com/posts/go-mpg-concurrency/</link><pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/go-mpg-concurrency/</guid><description>&lt;p>Golang 的高并发能力是通过协程 goroutine 实现的，在 Go 语言的开发中，每涉及到 goroutine 的相关功能实现时，都会意识到自己需要对 MPG 的模型有一个大概的了解，在此基础上才能做好开发上的决策，本篇也即为 MPG 并发调度模型的学习笔记了。&lt;/p></description></item><item><title>Go 语言的 Context 源码分析</title><link>https://yindongliang.com/posts/golang-context/</link><pubDate>Tue, 24 Nov 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/golang-context/</guid><description>&lt;p>研究 Context 的源码，有助于对结合运用 interface 和 struct 的理解，以及对其他三方框架对 Context 接口的重新实现也能有一定认识，在实际开发中更是非常有帮助。Context 的源码非常短小，加上大概一半的注释整个文件也才 500 行，500 行就可以和面试官扯一个小时，ROI 巨大，确定不研究下么。&lt;/p></description></item><item><title>Go 语言中 Channel 的实现</title><link>https://yindongliang.com/posts/golang-channel/</link><pubDate>Fri, 06 Nov 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/golang-channel/</guid><description>&lt;p>关于 Go 并发设计的哲学中，最常见的一句话就是：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。Go 语言采用 CSP（Communicating sequential processes）并发模型，底层运用 Channel 实现其特性，如果不对 Channel 有一番了解，也就很难真正掌握 Go 语言独特的并发技术。&lt;/p></description></item><item><title>Gin Web 框架中 Middleware 的实现原理</title><link>https://yindongliang.com/posts/gin-middleware/</link><pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/gin-middleware/</guid><description>&lt;p>Gin 和很多 Web 框架一样实现了 middleware（中间件）的功能，通过 Gin 提供的中间件，我们在业务逻辑处理每个请求之前进行一些通用的逻辑，比如身份校验、数据解密、签名认证、服务限流等功能。&lt;/p></description></item><item><title>浅谈 Django-REST-Framework 的设计与源码</title><link>https://yindongliang.com/posts/talk-about-django-rest-framework/</link><pubDate>Thu, 20 Oct 2016 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/talk-about-django-rest-framework/</guid><description>&lt;p>最近又重新接触 DRF，翻看文档发现，当时很难理解的东西，如今一看就懂了，顺带看了源码，也比较容易理解，至少比 Django 的源码简单不少。下面开始从 DRF 的设计和源码两个方面，结合自己的看法，谈谈DRF。&lt;/p></description></item></channel></rss>