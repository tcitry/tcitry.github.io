<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>操作系统 on LYon's Blog</title><link>https://yindongliang.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 操作系统 on LYon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Wed, 22 Oct 2025 19:25:18 +0800</lastBuildDate><atom:link href="https://yindongliang.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>系统调用</title><link>https://yindongliang.com/docs/Clang/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Clang/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid><description>&lt;p>Unix 操作系统通过一系列的系统调用提供服务，这些系统调用实际上是操作系统内的函数，它们可以被用户程序调用。本文介绍如何在 C 语言程序中使用一些重要的系统调用。&lt;/p></description></item><item><title>Actor 模型</title><link>https://yindongliang.com/docs/Apple/Swift/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Actor-%E6%A8%A1%E5%9E%8B/</link><pubDate>Sat, 22 Feb 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Apple/Swift/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Actor-%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h2 id="actor-模型详解">&lt;strong>Actor 模型详解&lt;/strong>&lt;a class="anchor" href="#actor-%e6%a8%a1%e5%9e%8b%e8%af%a6%e8%a7%a3">#&lt;/a>&lt;/h2>
&lt;p>Actor 模型是一种并发编程范式，其核心思想是通过&lt;strong>数据隔离&lt;/strong>和&lt;strong>异步消息传递&lt;/strong>解决多线程环境下的数据竞争问题。以下是其核心概念、设计背景及实现思想的详细解析：&lt;/p></description></item><item><title>Linux 运维</title><link>https://yindongliang.com/docs/Linux/Linux-%E8%BF%90%E7%BB%B4/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Linux/Linux-%E8%BF%90%E7%BB%B4/</guid><description>&lt;h2 id="权限系统">权限系统&lt;a class="anchor" href="#%e6%9d%83%e9%99%90%e7%b3%bb%e7%bb%9f">#&lt;/a>&lt;/h2>
&lt;p>Linux 系统使用一个专门的 &lt;code>/etc/passwd&lt;/code> 文件来匹配登录名与对应的 UID 值，用户密码不保存在此文件，而是在 &lt;code>/etc/shadow&lt;/code> 中，只有特定程序或 root 才可以访问。&lt;/p>
&lt;h3 id="用户管理">用户管理&lt;a class="anchor" href="#%e7%94%a8%e6%88%b7%e7%ae%a1%e7%90%86">#&lt;/a>&lt;/h3>
&lt;p>使用 &lt;code>useradd&lt;/code> 来创建新用户，&lt;code>userdel&lt;/code> 来删除用户，&lt;code>usermod&lt;/code> 来修改用户信息。&lt;/p></description></item><item><title>I/O 多路复用机制</title><link>https://yindongliang.com/posts/io-multiplexing/</link><pubDate>Sun, 04 Sep 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/io-multiplexing/</guid><description>&lt;p>面试问的太多了，还是专门整理一下吧，理清知识结构。&lt;/p>
&lt;h2 id="总览">总览&lt;a class="anchor" href="#%e6%80%bb%e8%a7%88">#&lt;/a>&lt;/h2>
&lt;p>首先需要注意的是，下面讨论的几种 I/O 模型都属于同步（synchronous） I/O 操作，至于异步（asynchronous） I/O 操作，以后再说。&lt;/p></description></item><item><title>操作系统的设备管理</title><link>https://yindongliang.com/posts/device-management-in-os/</link><pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/device-management-in-os/</guid><description>&lt;p>计算机除了 CPU、内存、硬盘，还需要各种设备才能实现对计算机的操作。本文讨论计算机是如何管理设备的输入输出的。&lt;/p>
&lt;h2 id="设备控制器">设备控制器&lt;a class="anchor" href="#%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%99%a8">#&lt;/a>&lt;/h2>
&lt;p>设备控制器接收 CPU 发来的命令，去控制 I/O 设备工作，使 CPU 从繁杂缓慢的设备控制事务中解放出来。当 CPU 要操作 I/O 设备时，首先要启动这个设备，一方面将启动命令发送给设备控制器，另一方面通过地址线将 I/O 设备的地址发给设备控制器，设备控制器对收到的地址进行译码，再根据所译出的命令对相应的设备进行操作。&lt;/p></description></item><item><title>操作系统的文件系统</title><link>https://yindongliang.com/posts/file-system-in-os/</link><pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/file-system-in-os/</guid><description>&lt;p>文件是操作系统进行存储时使用最多的抽象之一，在 Linux 中，一切皆文件。本文以 Linux 为例，介绍下文件系统中的基础概念。&lt;/p>
&lt;h2 id="数据结构">数据结构&lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#&lt;/a>&lt;/h2>
&lt;p>每个文件实质上是一个有名字的字符序列，序列的内容为&lt;em>文件数据&lt;/em>（file data），而序列的长度、序列的修改时间等描述文件数据的属性等其他信息称为&lt;em>文件元数据&lt;/em>（file metadata）。&lt;/p></description></item><item><title>常见的垃圾回收算法</title><link>https://yindongliang.com/posts/GC-algorithms/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/GC-algorithms/</guid><description>&lt;p>本来想直接看下 Go 的垃圾回收机制，但是发现自己现在对内存管理和垃圾回收的了解都比较少，所以只能先来研究下常见的垃圾回收算法了，本篇即是《&lt;a href="https://book.douban.com/subject/26821357/">垃圾回收的算法与实现&lt;/a>》的学习笔记，目标是能够描述清楚各种 GC 算法的复杂度、优缺点。&lt;/p></description></item><item><title>操作系统的任务调度机制（四）通信、同步和死锁</title><link>https://yindongliang.com/posts/the-communication-synchronization-and-deadlock-of-task-scheduling-in-os/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/the-communication-synchronization-and-deadlock-of-task-scheduling-in-os/</guid><description>&lt;p>操作系统进程间通信、以及并发的处理方式，是调度器能够高效运行的基础，上篇说了调度器的策略，本篇继续深入调度器的背后，看看进程间通信、同步和并发控制如何支撑着这套现代操作系统的调度机制。内容上是按照进程间通信引出了并发控制方法：同步原语，并发又进而引出了死锁问题。&lt;/p></description></item><item><title>操作系统的任务调度机制（三）调度器策略</title><link>https://yindongliang.com/posts/the-scheduler-policy-of-task-scheduling-in-os/</link><pubDate>Sun, 14 Feb 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/the-scheduler-policy-of-task-scheduling-in-os/</guid><description>&lt;p>操作系统中的调度器有任务调度、I/O 调度（以后再说）、内存调度（之前提到的换页策略）等多种类型，本文主要关注任务调度。在单核多进程并发的环境里，进程之间并不是“并行”执行的，实际上在任何时刻都只有一个进程处于执行状态，背后是 CPU 在不停地进行上下文切换，让你看起来像是多个任务在并行执行。而任务调度器要做的就是决定选择哪个进程执行，什么时候执行，执行多久，下面开始详细介绍。&lt;/p></description></item><item><title>操作系统的任务调度机制（二）进程和线程模型</title><link>https://yindongliang.com/posts/the-process-and-thread-of-task-scheduling-in-os/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/the-process-and-thread-of-task-scheduling-in-os/</guid><description>&lt;h2 id="进程模型">进程模型&lt;a class="anchor" href="#%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b">#&lt;/a>&lt;/h2>
&lt;p>进程的概念是随着多道批处理系统的概念产生的，MULTICS 之前还叫 Job，后来它为了区别这个 IBM 公司发明的术语改为了 Process，进程不是程序，程序是放入内存的一段数据，而进程是带有状态的一种活动、一系列动作，它保存了程序运行时的一系列状态。如果一个程序运行两遍，那就算作是两个进程，只不过可能只有一个副本被考入内存。&lt;/p></description></item><item><title>操作系统的任务调度机制（一）演进历史</title><link>https://yindongliang.com/posts/the-evolution-history-of-task-scheduling-in-os/</link><pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/the-evolution-history-of-task-scheduling-in-os/</guid><description>&lt;p>之前说到了 Goroutine 的运行时调度机制，引发了我对操作系统调度的进一步回忆，发现已经非常模糊，只能从头再来。在很多大型系统中，包括编程语言，都有调度器的概念，其核心的作用都是对有限的处理器资源进行最大化利用。具体到我目前关注的，也就是操作系统中关于进程和线程的调度策略以及并发处理机制。&lt;/p></description></item><item><title>操作系统的内存管理机制</title><link>https://yindongliang.com/posts/memory-management-in-os/</link><pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/memory-management-in-os/</guid><description>&lt;p>继续复习操作系统，话说随着 CPU 计算资源的性能开始过剩，压在内存身上的担子越来越重了，堪称新时期的性能瓶颈，对操作系统来说，内存管理机制也要进行近乎极致的优化才可以充分发挥 CPU 的正常水平。&lt;/p></description></item><item><title>使用 DOSBox 和 Debug 命令调试汇编程序</title><link>https://yindongliang.com/posts/dosbox-and-debug-usage/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/dosbox-and-debug-usage/</guid><description>&lt;p>正在看王爽的《汇编语言》，因为我在 Mac M1 环境，按书上做汇编实验的话，搜索了一圈发现 DOSBox 应该可以满足我的需要，它是一个跨平台的可以运行 MS-DOS 的模拟器。&lt;/p>
&lt;h2 id="dosbox">DOSBox&lt;a class="anchor" href="#dosbox">#&lt;/a>&lt;/h2>
&lt;p>下载地址 &lt;a href="https://www.dosbox.com/">https://www.dosbox.com/&lt;/a>&lt;/p></description></item><item><title>汇编语言不会编？</title><link>https://yindongliang.com/posts/writing-assembly-code/</link><pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/writing-assembly-code/</guid><description>&lt;p>&lt;a href="https://yindongliang.com/posts/cpu-register">上篇&lt;/a>已经介绍了 CPU 的寄存器种类，知道了程序是由指令和数据组成的，以及 CPU 是如何通过寄存器运行程序的，那么现在可以真正了解下汇编指令集了。&lt;/p>
&lt;h2 id="前提须知">前提须知&lt;a class="anchor" href="#%e5%89%8d%e6%8f%90%e9%a1%bb%e7%9f%a5">#&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>因为不同 CPU 架构的指令集都不尽相同，汇编语言通常不具有可移植性，这里介绍的还是以 16 位的 8086CPU 为主。&lt;/li>
&lt;li>下面的描述，用 &lt;code>()&lt;/code> 表示一个寄存器或内存单元中的内容，比如（ax）表示 ax 中的内容，（20000H）表示内存 2000H 单元的内容。&lt;/li>
&lt;li>下面的描述，用 &lt;code>idata&lt;/code> 表示常量，比如 &lt;code>mov ax, [idata]&lt;/code> 就代表 &lt;code>mov ax, [1]&lt;/code>、&lt;code>mov ax, [2]&lt;/code>、&lt;code>mov ax, [3]&lt;/code>。&lt;/li>
&lt;li>reg 表示一个寄存器，比如：ax、bx、cx、dx、ah、bh、bl、ch、cl、dh、dl、sp、bp、si、di。&lt;/li>
&lt;li>sreg 表示一个段寄存器，比如：ds、ss、cs、es。&lt;/li>
&lt;/ul>
&lt;h2 id="伪指令宏">伪指令（宏）&lt;a class="anchor" href="#%e4%bc%aa%e6%8c%87%e4%bb%a4%e5%ae%8f">#&lt;/a>&lt;/h2>
&lt;p>用汇编语言写的源程序，包括伪指令和汇编指令。首先主要知道伪指令，它区别于常见的汇编指令。伪指令没有对应的机器指令，最终也不会被 CPU 执行，而是由编译器执行的指令，用于指示编译器如何汇编源程序。&lt;/p></description></item><item><title>CPU 与寄存器</title><link>https://yindongliang.com/posts/cpu-register/</link><pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/cpu-register/</guid><description>&lt;p>看 Go 语言的调度器相关内容的时候里面很多内存堆栈、寄存器的概念，一开始没怎么看懂，需要先回来复习下相关的基础知识，早知道大学就好好学了。&lt;/p>
&lt;h2 id="前提须知">前提须知&lt;a class="anchor" href="#%e5%89%8d%e6%8f%90%e9%a1%bb%e7%9f%a5">#&lt;/a>&lt;/h2>
&lt;ol>
&lt;li>下面的内容都以 16 位的 8086CPU 的情况为准。&lt;/li>
&lt;li>通常写一条汇编指令或一个寄存器的名称，不区分大小写。&lt;/li>
&lt;li>为了区分不同的进制，在十六进制表示的数据的后面加 &lt;code>H&lt;/code>，在二进制表示的数据后面加 &lt;code>B&lt;/code>。&lt;/li>
&lt;li>现在很多实际的源码中一般都是 32 位或者 64 位的寄存器表示。比如表示 SP 的 32 位寄存器是 ESP，对应 64 位寄存器是 RSP，其他通用寄存器也是同理。&lt;/li>
&lt;/ol>
&lt;h2 id="cpu">CPU&lt;a class="anchor" href="#cpu">#&lt;/a>&lt;/h2>
&lt;p>CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。寄存器可用来暂存指令、数据等处理对象。根据种类的不同，一个 CPU 内部会有 20～100 个寄存器。控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。运算器负责运算从内存读入寄存器的数据。时钟负责发出CPU开始计时的时钟信号。&lt;/p></description></item></channel></rss>