<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Django on LYon's Blog</title><link>https://yindongliang.com/tags/Django/</link><description>Recent content in Django on LYon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 18 Oct 2025 13:05:57 +0800</lastBuildDate><atom:link href="https://yindongliang.com/tags/Django/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Django 查询数据库的分表</title><link>https://yindongliang.com/posts/django-query-splited-table/</link><pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/django-query-splited-table/</guid><description>&lt;h2 id="业务背景">业务背景&lt;a class="anchor" href="#%e4%b8%9a%e5%8a%a1%e8%83%8c%e6%99%af">#&lt;/a>&lt;/h2>
&lt;p>最近已经转到 Go 下面进行日常工作的开发，我的一个后台项目有一些内部轻量的数据查询需要，考虑需求的复杂度不高，就平常自己和同事几个人使用，没必要专门开发一个前端项目来进行数据查询，于是我想到了老本行 Django，由于 Django 出色的后台管理功能，我几乎不用做多少开发，只需要配置下 Model 层结构就可以了，唯一的问题就是这个 Go 项目的数据在数据库中是分表管理的。&lt;/p></description></item><item><title>Django 中 N+1 查询问题优化</title><link>https://yindongliang.com/posts/django-n1-query/</link><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/django-n1-query/</guid><description>&lt;p>Django ORM 框架虽然很好用，但是如果不注意，在查询时很容易引发 N + 1 的查询问题。&lt;/p>
&lt;h2 id="n--1-问题">N + 1 问题&lt;a class="anchor" href="#n--1-%e9%97%ae%e9%a2%98">#&lt;/a>&lt;/h2>
&lt;p>考虑 &lt;code>文章+作者&lt;/code> 这样的 Model 层设计，在这个模型中，Author 和 Article 是一对多的关系。&lt;/p></description></item><item><title>Django 的中间件执行顺序</title><link>https://yindongliang.com/posts/django-middleware/</link><pubDate>Sun, 12 Nov 2017 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/django-middleware/</guid><description>&lt;p>中间件是 Django 用来处理请求和响应的钩子框架。它是一个轻量级的、底层级的“插件”系统，用于全局性地控制 Django 的输入或输出。&lt;/p>
&lt;h2 id="middleware">MIDDLEWARE&lt;a class="anchor" href="#middleware">#&lt;/a>&lt;/h2>
&lt;p>Django 自带了一些已经内置的中间件，你可以直接使用，它们被记录在 &lt;a href="https://docs.djangoproject.com/zh-hans/4.0/ref/middleware/">built-in middleware reference&lt;/a> 中。&lt;/p></description></item><item><title>Django 的软删除设计</title><link>https://yindongliang.com/posts/django-soft-delete/</link><pubDate>Thu, 23 Feb 2017 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/django-soft-delete/</guid><description>&lt;p>设计一个 Django 的软删除方案，要求数据库在删除的时候不能物理删除数据，同时尽量不要太侵入代码业务。&lt;/p>
&lt;p>这里用到了 Django 的 Manager，它赋予了 Django Model 操作数据库的能力，每个 Model 都包含一个 Manager，比如我们常用的 &lt;code>objects&lt;/code> 就是默认的 Manger。&lt;/p></description></item><item><title>浅谈 Django-REST-Framework 的设计与源码</title><link>https://yindongliang.com/posts/talk-about-django-rest-framework/</link><pubDate>Thu, 20 Oct 2016 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/talk-about-django-rest-framework/</guid><description>&lt;p>最近又重新接触 DRF，翻看文档发现，当时很难理解的东西，如今一看就懂了，顺带看了源码，也比较容易理解，至少比 Django 的源码简单不少。下面开始从 DRF 的设计和源码两个方面，结合自己的看法，谈谈DRF。&lt;/p></description></item><item><title>Ubuntu 下部署 Django 应用</title><link>https://yindongliang.com/posts/ubuntu-deploy-django/</link><pubDate>Sat, 11 Jul 2015 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/ubuntu-deploy-django/</guid><description>&lt;p>做了一个Django小应用，主要内容是一个论坛，经过好几天的研究，也可以在服务器端运行了，以下所有代码中的操作都需要在命令行运行。&lt;/p>
&lt;h2 id="安装mysql">安装MySQL&lt;a class="anchor" href="#%e5%ae%89%e8%a3%85mysql">#&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt-get update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get install mysql-server mysql-client&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据提示设置 MySQL root用户密码&lt;/p></description></item></channel></rss>