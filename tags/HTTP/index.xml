<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTP on LYon's Blog</title><link>https://yindongliang.com/tags/HTTP/</link><description>Recent content in HTTP on LYon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 18 Oct 2025 13:05:57 +0800</lastBuildDate><atom:link href="https://yindongliang.com/tags/HTTP/index.xml" rel="self" type="application/rss+xml"/><item><title>Cookie 机制</title><link>https://yindongliang.com/posts/Cookie-%E6%9C%BA%E5%88%B6/</link><pubDate>Sun, 14 Sep 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/Cookie-%E6%9C%BA%E5%88%B6/</guid><description>&lt;p>我们来详细解析一下服务器和浏览器是如何协同管理 Cookie 的。Cookie 是维持 HTTP 无状态协议状态的关键技术，其管理机制涉及服务器创建、浏览器存储与发送、以及双方的安全约束。&lt;/p></description></item><item><title>JWT 介绍和场景示例</title><link>https://yindongliang.com/posts/jwt-api-auth/</link><pubDate>Sun, 14 Sep 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/jwt-api-auth/</guid><description>&lt;h3 id="一jwt-是什么">一、JWT 是什么？&lt;a class="anchor" href="#%e4%b8%80jwt-%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://www.jwt.io/">&lt;strong>JWT&lt;/strong>&lt;/a> 的英文全称是 JSON Web Token。它是一种开放的、行业标准的方法，用于在双方之间安全地传输信息作为 JSON 对象。&lt;/p>
&lt;p>最关键的特点是：&lt;strong>这些信息是经过数字签名的，因此可以被验证和信任&lt;/strong>。&lt;/p></description></item><item><title>Chrome URLs</title><link>https://yindongliang.com/docs/Frontend/Chrome/</link><pubDate>Sun, 07 Sep 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Frontend/Chrome/</guid><description>&lt;p>Chrome 浏览器提供了大量以 &lt;code>chrome://&lt;/code> 开头的特殊内部页面（有时称为 &amp;ldquo;chrome URLs&amp;rdquo; 或 &amp;ldquo;about URLs&amp;rdquo;），这些页面用于访问浏览器的各种内部信息、设置、调试和实验功能。下面是一些比较常用和实用的内部地址：&lt;/p></description></item><item><title>WebHook URL 概念</title><link>https://yindongliang.com/docs/Linux/WebHook-URL/</link><pubDate>Sat, 06 Sep 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Linux/WebHook-URL/</guid><description>&lt;p>关于 Webhook URL 本身并没有一个全球统一的硬性标准，但它有一些广泛接受的实践和常见要求，这些“事实上的标准”确保了不同系统之间能够可靠、安全地协作。&lt;/p>
&lt;p>下面这个表格汇总了 Webhook URL 及请求的主要实践和常见要求，希望能帮你快速了解：&lt;/p></description></item><item><title>SWR</title><link>https://yindongliang.com/links/202508/SWR/</link><pubDate>Tue, 19 Aug 2025 00:00:00 +0000</pubDate><guid>https://yindongliang.com/links/202508/SWR/</guid><description>&lt;p>“SWR” 这个名字来自于 &lt;code>stale-while-revalidate&lt;/code>：一种由 &lt;a href="https://tools.ietf.org/html/rfc5861">HTTP RFC 5861(opens in a new tab)&lt;/a> 推广的 HTTP 缓存失效策略。这种策略首先从缓存中返回数据（过期的），同时发送 fetch 请求（重新验证），最后得到最新数据。&lt;/p></description></item><item><title>AJAX 是什么？</title><link>https://yindongliang.com/posts/what-is-AJAX/</link><pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/what-is-AJAX/</guid><description>&lt;p>这个问题既熟悉又有点陌生，先看概念。AJAX 是 &lt;em>Asynchronous Javavascript XML&lt;/em> 的缩写，即异步 JavaScript 和 XML。使用 AJAX 技术可以在无需重新加载整个网页的情况下，能够更新部分网页，从而给带来更好的用户体验。另外 AJAX 不仅使用 XML，实际上由于 JSON 结构的易读和轻量反而更受欢迎。&lt;/p></description></item><item><title>WebSocket 是什么？</title><link>https://yindongliang.com/posts/what-is-websocket/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/what-is-websocket/</guid><description>&lt;p>WebSocket 是 HTML5 开始提供的一种网络传输协议，可以在单个 TCP 连接上进行全双工通信，位于 OSI 参考模型的应用层。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建&lt;strong>持久性&lt;/strong>的连接，并进行&lt;strong>双向&lt;/strong>数据传输。&lt;/p></description></item><item><title>TCP/IP 协议理论基础整理</title><link>https://yindongliang.com/posts/tcpip-questions/</link><pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/tcpip-questions/</guid><description>&lt;p>因为 TCP/IP 协议中每个协议都是层层包装、依赖，分开说可能并不会更容易掌握这些理论知识，所以这里把这些协议都放在了一起。&lt;/p>
&lt;h2 id="名词解释">名词解释&lt;a class="anchor" href="#%e5%90%8d%e8%af%8d%e8%a7%a3%e9%87%8a">#&lt;/a>&lt;/h2>
&lt;h3 id="七层和四层模型">七层和四层模型&lt;a class="anchor" href="#%e4%b8%83%e5%b1%82%e5%92%8c%e5%9b%9b%e5%b1%82%e6%a8%a1%e5%9e%8b">#&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://cdn.yindongliang.com/uPic/20160731161720376.gif">这里&lt;/a>有一张图比较详细。&lt;/p>
&lt;p>OSI 七层参考模型包括：&lt;/p>
&lt;ul>
&lt;li>应用层：应用程序可直接使用的协议，如 HTTP、FTP。&lt;/li>
&lt;li>表示层：主要是数据格式转化，比如压缩、加密。&lt;/li>
&lt;li>会话层：定义了如何建立及开始会话，比如 TLS。&lt;/li>
&lt;li>传输层：接受上一层的数据，并将其交给网络层，且保证数据有效到达。&lt;/li>
&lt;li>网络层：控制子网的运行，提供标准的端对端的包传输。&lt;/li>
&lt;li>数据链路层：定义了单个链路上如何传输数据。&lt;/li>
&lt;li>物理层：传输介质，硬件。&lt;/li>
&lt;/ul>
&lt;p>四层协议包括：&lt;/p></description></item><item><title>HTTP/2 概览</title><link>https://yindongliang.com/posts/http2-101/</link><pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/http2-101/</guid><description>&lt;h2 id="http2-的背景">HTTP/2 的背景&lt;a class="anchor" href="#http2-%e7%9a%84%e8%83%8c%e6%99%af">#&lt;/a>&lt;/h2>
&lt;p>HTTP/2 协议发布于 2015 年，距离上一个版本 HTTP/1 的发布已经过去了 20 多年，20 年里，随着互联网规模的指数级增长，网络已经成为人们生活的一部分，各种应用对响应要求也越来越严苛，HTTP/1 根本上的性能问题也随之暴露出来。&lt;/p></description></item><item><title>HTTPS 的 SSL/TLS 协议</title><link>https://yindongliang.com/posts/https-ssl-tls-protocol/</link><pubDate>Thu, 16 Dec 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/https-ssl-tls-protocol/</guid><description>&lt;h2 id="https-简介">HTTPS 简介&lt;a class="anchor" href="#https-%e7%ae%80%e4%bb%8b">#&lt;/a>&lt;/h2>
&lt;p>通过上一篇的&lt;a href="http://localhost:1313/posts/https-algorithems/">HTTPS 之密码学基础&lt;/a>，现在可以正式进入 HTTPS 的介绍了。HTTPS 指的是超文本传输安全协议（&lt;strong>H&lt;/strong>yper&lt;strong>T&lt;/strong>ext &lt;strong>T&lt;/strong>ransfer &lt;strong>P&lt;/strong>rotocol &lt;strong>S&lt;/strong>ecure），顾名思义，比 HTTP 多了一个“安全”，而这里的安全指的就是 SSL/TLS 协议了，即 HTTPS 是由 HTTP + SSL/TLS 协议组成的。&lt;/p></description></item><item><title>HTTPS 的密码学基础</title><link>https://yindongliang.com/posts/https-algorithems/</link><pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/https-algorithems/</guid><description>&lt;p>本来打算直接总结下 HTTPS，但是发现要写的很多内容其实都依靠密码学的基础概念，其实我在阅读别的资料的时候发现基本也是这样，不然说的时候上下文都串不起来，甚至可以说研究 HTTPS 约等于在研究加密算法。所以还是专门分一篇来说一下加密，这样后面说 SSL/TLS 的时候就可以拉通底层概念了。&lt;/p></description></item><item><title>跨域相关问题</title><link>https://yindongliang.com/posts/http-cross-domain-problem/</link><pubDate>Sat, 21 Aug 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/http-cross-domain-problem/</guid><description>&lt;p>本文先从 &lt;strong>CSRF&lt;/strong> 攻击的介绍开始，说明了跨域存在的问题，然后引入浏览器&lt;strong>同源策略&lt;/strong>的概念，明白了要限制跨域的原因后，再给出了标准的跨域请求方案：&lt;strong>CORS&lt;/strong>，所以总体上就三部分：CSRF、同源策略、CORS，文章有点长但不用慌，按顺序看就可以了。&lt;/p></description></item><item><title>浏览器中的 HTTP 缓存使用策略</title><link>https://yindongliang.com/posts/http-caching-in-browser/</link><pubDate>Sat, 12 Jun 2021 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/http-caching-in-browser/</guid><description>&lt;p>浏览器使用缓存数据有非常多的好处，很多情况下静态资源会比 js 代码更大，同时修改的频率又非常低，通过对静态资源使用缓存，可以有效减少重复请求，从而节省网络带宽、降低服务器的请求压力。&lt;/p></description></item><item><title>了解下 Protobuf 相关概念</title><link>https://yindongliang.com/posts/hello-protobuf/</link><pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/hello-protobuf/</guid><description>&lt;p>说 Protobuf 之前，要先知道 RPC 是什么，可以说 Protobuf 是实现 RPC 的接口描述语言。&lt;/p>
&lt;h2 id="rpc">RPC&lt;a class="anchor" href="#rpc">#&lt;/a>&lt;/h2>
&lt;p>RPC，全称 Remote Procedure Call，中文叫远程过程调用。&lt;/p>
&lt;p>go 语言基于标准库实现了一套自己的 RPC 调用规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p></description></item><item><title>说说实际工作中 GraphQL 的使用体验</title><link>https://yindongliang.com/posts/talk-about-graphql/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/talk-about-graphql/</guid><description>&lt;h2 id="背景">背景&lt;a class="anchor" href="#%e8%83%8c%e6%99%af">#&lt;/a>&lt;/h2>
&lt;p>接触 GraphQL 是工作中需要有一个项目，用来聚合内部很多其他微服务的接口然后统一暴露给外部使用，在这样的场景下，对项目有几点需求：&lt;/p>
&lt;ul>
&lt;li>能够让外部业务方对接方便，当然最好有接口文档。&lt;/li>
&lt;li>各个业务方可以根据他们自己的需要自己选择字段集合。&lt;/li>
&lt;li>项目提供的接口可以被不同的语言框架通过 HTTP 调用，比如前端、Python、Go 等。&lt;/li>
&lt;/ul>
&lt;p>基于以上的需求，在组内一位大神的提议下，顺理成章的使用了 GraphQL 作为解决方案，经过半年多的迭代维护，今天特来从后端角度说下使用体验。&lt;/p></description></item></channel></rss>