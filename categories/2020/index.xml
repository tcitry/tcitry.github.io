<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2020 on LYon's Blog</title><link>https://yindongliang.com/categories/2020/</link><description>Recent content in 2020 on LYon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 18 Oct 2025 13:05:57 +0800</lastBuildDate><atom:link href="https://yindongliang.com/categories/2020/index.xml" rel="self" type="application/rss+xml"/><item><title>语言基础</title><link>https://yindongliang.com/docs/Golang/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</link><pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Golang/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</guid><description>&lt;h2 id="变量声明">变量声明&lt;a class="anchor" href="#%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e">#&lt;/a>&lt;/h2>
&lt;p>两种方式 &lt;code>var&lt;/code> 和 &lt;code>:=&lt;/code>，没有&lt;code>let&lt;/code> 关键字。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">var&lt;/span> &lt;span style="color:#aa89ea">a&lt;/span> &lt;span style="color:#e5c07b">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aa89ea">a&lt;/span> &lt;span style="color:#54b1c7">:=&lt;/span> &lt;span style="color:#d19a66">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8a93a5;font-style:italic">// 可以两个同时赋值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aa89ea">a&lt;/span>&lt;span style="color:#abb2bf">,&lt;/span> &lt;span style="color:#aa89ea">b&lt;/span> &lt;span style="color:#54b1c7">:=&lt;/span> &lt;span style="color:#d19a66">0&lt;/span>&lt;span style="color:#abb2bf">,&lt;/span> &lt;span style="color:#d19a66">0&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="变量类型">变量类型&lt;a class="anchor" href="#%e5%8f%98%e9%87%8f%e7%b1%bb%e5%9e%8b">#&lt;/a>&lt;/h2>
&lt;h3 id="int">int&lt;a class="anchor" href="#int">#&lt;/a>&lt;/h3>
&lt;h4 id="进制">进制&lt;a class="anchor" href="#%e8%bf%9b%e5%88%b6">#&lt;/a>&lt;/h4>
&lt;p>十六进制 0x 开头为十六进制&lt;/p>
&lt;p>八进制 0 开头为八进制&lt;/p>
&lt;h4 id="rune">rune&lt;a class="anchor" href="#rune">#&lt;/a>&lt;/h4>
&lt;p>rune 为 int32 的别名，它完全等价于 int32，习惯上用它来区别字符值和整数值，用 rune 表示字符的 Unicode 码值。&lt;/p></description></item><item><title>标准库</title><link>https://yindongliang.com/docs/Golang/%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Golang/%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>&lt;h2 id="buildin">Buildin&lt;a class="anchor" href="#buildin">#&lt;/a>&lt;/h2>
&lt;p>buildin 文档 &lt;a href="https://golang.org/pkg/builtin">https://golang.org/pkg/builtin&lt;/a>&lt;/p>
&lt;h3 id="uintptr">uintptr&lt;a class="anchor" href="#uintptr">#&lt;/a>&lt;/h3>
&lt;p>足够大、可以存放任何指针地址的类型。常用来将指针转换后进行寻址计算。&lt;/p>
&lt;blockquote class='book-hint '>
&lt;p>uintptr is an integer type that is large enough to hold the bit pattern of any pointer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">func&lt;/span> &lt;span style="color:#00b1f7">Offsetof&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">x&lt;/span> &lt;span style="color:#aa89ea">ArbitraryType&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span> &lt;span style="color:#e5c07b">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">func&lt;/span> &lt;span style="color:#00b1f7">Sizeof&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">x&lt;/span> &lt;span style="color:#aa89ea">ArbitraryType&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span> &lt;span style="color:#e5c07b">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">func&lt;/span> &lt;span style="color:#00b1f7">Alignof&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">x&lt;/span> &lt;span style="color:#aa89ea">ArbitraryType&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span> &lt;span style="color:#e5c07b">uintptr&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>&lt;h3 id="错误示例">错误示例&lt;a class="anchor" href="#%e9%94%99%e8%af%af%e7%a4%ba%e4%be%8b">#&lt;/a>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">func&lt;/span> &lt;span style="color:#00b1f7">main&lt;/span>&lt;span style="color:#abb2bf">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#aa89ea">n&lt;/span> &lt;span style="color:#54b1c7">:=&lt;/span> &lt;span style="color:#aa89ea">Num&lt;/span>&lt;span style="color:#abb2bf">{&lt;/span>&lt;span style="color:#aa89ea">i&lt;/span>&lt;span style="color:#abb2bf">:&lt;/span> &lt;span style="color:#98c379">&amp;#34;EDDYCJY&amp;#34;&lt;/span>&lt;span style="color:#abb2bf">,&lt;/span> &lt;span style="color:#aa89ea">j&lt;/span>&lt;span style="color:#abb2bf">:&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>&lt;span style="color:#abb2bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#aa89ea">nPointer&lt;/span> &lt;span style="color:#54b1c7">:=&lt;/span> &lt;span style="color:#aa89ea">unsafe&lt;/span>&lt;span style="color:#abb2bf">.&lt;/span>&lt;span style="color:#00b1f7">Pointer&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#54b1c7">&amp;amp;&lt;/span>&lt;span style="color:#aa89ea">n&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#54b1c7">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#aa89ea">ptr&lt;/span> &lt;span style="color:#54b1c7">:=&lt;/span> &lt;span style="color:#e5c07b">uintptr&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">nPointer&lt;/span>&lt;span style="color:#abb2bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#aa89ea">njPointer&lt;/span> &lt;span style="color:#54b1c7">:=&lt;/span> &lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#54b1c7">*&lt;/span>&lt;span style="color:#e5c07b">int64&lt;/span>&lt;span style="color:#abb2bf">)(&lt;/span>&lt;span style="color:#aa89ea">unsafe&lt;/span>&lt;span style="color:#abb2bf">.&lt;/span>&lt;span style="color:#00b1f7">Pointer&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">ptr&lt;/span> &lt;span style="color:#54b1c7">+&lt;/span> &lt;span style="color:#aa89ea">unsafe&lt;/span>&lt;span style="color:#abb2bf">.&lt;/span>&lt;span style="color:#00b1f7">Offsetof&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">n&lt;/span>&lt;span style="color:#abb2bf">.&lt;/span>&lt;span style="color:#aa89ea">j&lt;/span>&lt;span style="color:#abb2bf">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#54b1c7">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#abb2bf">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>uintptr&lt;/code> 类型不能存储在临时变量中。因为从 GC 的角度来看，&lt;code>uintptr&lt;/code> 类型的临时变量只是一个无符号整数，并不知道它是一个指针地址。因此当满足一定条件后，&lt;code>ptr&lt;/code>这个临时变量是可能被垃圾回收掉的。&lt;/p></description></item><item><title>命令行</title><link>https://yindongliang.com/docs/Golang/%E5%91%BD%E4%BB%A4%E8%A1%8C/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Golang/%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid><description>&lt;p>自带的主要有 build, clean, get, install, list, run, and test&lt;/p>
&lt;h2 id="run">run&lt;a class="anchor" href="#run">#&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go run main.go&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>-mod&lt;/code>选项，&lt;code>go help modules&lt;/code>查看详细，&lt;code>-mod&lt;/code> 在其他部分命令中也可指定。&lt;/p>
&lt;ul>
&lt;li>vendor&lt;/li>
&lt;li>mod&lt;/li>
&lt;li>readonly&lt;/li>
&lt;/ul>
&lt;h2 id="get">get&lt;a class="anchor" href="#get">#&lt;/a>&lt;/h2>
&lt;p>使用 @ 指定版本&lt;/p></description></item><item><title>代码规范</title><link>https://yindongliang.com/docs/Golang/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</link><pubDate>Wed, 21 Oct 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/docs/Golang/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</guid><description>&lt;h2 id="语言规范">语言规范&lt;a class="anchor" href="#%e8%af%ad%e8%a8%80%e8%a7%84%e8%8c%83">#&lt;/a>&lt;/h2>
&lt;p>控制 Goroutine 的生命周期&lt;/p>
&lt;p>使用 gofmt&lt;/p>
&lt;p>Context 一般作为第一个参数传参&lt;/p>
&lt;p>copy struct 时需注意 slice 的拷贝&lt;/p>
&lt;p>Don&amp;rsquo;t Panic&lt;/p>
&lt;p>pkg 里面的包最好有 example&lt;/p>
&lt;p>传值还是传指针？&lt;/p>
&lt;p>Error 未处理&lt;/p>
&lt;p>Share memory by communicating; don&amp;rsquo;t communicate by sharing memory.&lt;/p>
&lt;p>在 go 出去的方法里加 recover&lt;/p></description></item><item><title>Go 语言的 MPG 并发调度模型</title><link>https://yindongliang.com/posts/go-mpg-concurrency/</link><pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/go-mpg-concurrency/</guid><description>&lt;p>Golang 的高并发能力是通过协程 goroutine 实现的，在 Go 语言的开发中，每涉及到 goroutine 的相关功能实现时，都会意识到自己需要对 MPG 的模型有一个大概的了解，在此基础上才能做好开发上的决策，本篇也即为 MPG 并发调度模型的学习笔记了。&lt;/p></description></item><item><title>Go 语言的 Context 源码分析</title><link>https://yindongliang.com/posts/golang-context/</link><pubDate>Tue, 24 Nov 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/golang-context/</guid><description>&lt;p>研究 Context 的源码，有助于对结合运用 interface 和 struct 的理解，以及对其他三方框架对 Context 接口的重新实现也能有一定认识，在实际开发中更是非常有帮助。Context 的源码非常短小，加上大概一半的注释整个文件也才 500 行，500 行就可以和面试官扯一个小时，ROI 巨大，确定不研究下么。&lt;/p></description></item><item><title>Go 语言中 Channel 的实现</title><link>https://yindongliang.com/posts/golang-channel/</link><pubDate>Fri, 06 Nov 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/golang-channel/</guid><description>&lt;p>关于 Go 并发设计的哲学中，最常见的一句话就是：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。Go 语言采用 CSP（Communicating sequential processes）并发模型，底层运用 Channel 实现其特性，如果不对 Channel 有一番了解，也就很难真正掌握 Go 语言独特的并发技术。&lt;/p></description></item><item><title>权限系统通用的设计模型</title><link>https://yindongliang.com/posts/permission-system-models/</link><pubDate>Thu, 29 Oct 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/permission-system-models/</guid><description>&lt;p>权限系统是一个比较通用的系统，几乎所有的后台业务都会涉及到，关于权限系统的设计经过一些最佳实践也已经被总结成各种模型，比如 ACL、RBAC、ABAC、PBAC等，下面开始详细介绍。&lt;/p></description></item><item><title>了解下 Protobuf 相关概念</title><link>https://yindongliang.com/posts/hello-protobuf/</link><pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/hello-protobuf/</guid><description>&lt;p>说 Protobuf 之前，要先知道 RPC 是什么，可以说 Protobuf 是实现 RPC 的接口描述语言。&lt;/p>
&lt;h2 id="rpc">RPC&lt;a class="anchor" href="#rpc">#&lt;/a>&lt;/h2>
&lt;p>RPC，全称 Remote Procedure Call，中文叫远程过程调用。&lt;/p>
&lt;p>go 语言基于标准库实现了一套自己的 RPC 调用规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p></description></item><item><title>乒乓理财，了解一下？</title><link>https://yindongliang.com/posts/pingpang-financing/</link><pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/pingpang-financing/</guid><description>&lt;h2 id="谁需要看">谁需要看&lt;a class="anchor" href="#%e8%b0%81%e9%9c%80%e8%a6%81%e7%9c%8b">#&lt;/a>&lt;/h2>
&lt;p>如果你有100 万要理财，这个不适合你。如果你只有 1 万？那向你介绍一下我总结的理财方案~&lt;/p>
&lt;h2 id="认识乒乓球拍">认识乒乓球拍&lt;a class="anchor" href="#%e8%ae%a4%e8%af%86%e4%b9%92%e4%b9%93%e7%90%83%e6%8b%8d">#&lt;/a>&lt;/h2>
&lt;p>关于球拍的分类，我从各个角度出发整理了一个图：&lt;/p>
&lt;img src="https://cdn.yindongliang.com/uPic/pingpang-category.png" style="zoom:50%;" />
&lt;p>可见，正是球拍的种类非常之多，每种特性组合在一起，会发生各种各样的效果，这也是为什么球友们对器材津津乐道、各种尝试的原因，也是乒乓球拍多样性表现，况且现在还没有介绍胶皮的多样性。&lt;/p></description></item><item><title>Panic：assignment to entry in nil map</title><link>https://yindongliang.com/posts/go-panic-assignment-to-entry-in-nil-map/</link><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/go-panic-assignment-to-entry-in-nil-map/</guid><description>&lt;p>参考以下代码，运行时会报 panic: assignment to entry in nil map。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">package&lt;/span> &lt;span style="color:#aa89ea">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">import&lt;/span> &lt;span style="color:#98c379">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#76a9f9">func&lt;/span> &lt;span style="color:#00b1f7">main&lt;/span>&lt;span style="color:#abb2bf">()&lt;/span> &lt;span style="color:#abb2bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#76a9f9">var&lt;/span> &lt;span style="color:#aa89ea">m&lt;/span> &lt;span style="color:#76a9f9">map&lt;/span>&lt;span style="color:#abb2bf">[&lt;/span>&lt;span style="color:#e5c07b">string&lt;/span>&lt;span style="color:#abb2bf">]&lt;/span>&lt;span style="color:#e5c07b">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#aa89ea">m&lt;/span>&lt;span style="color:#abb2bf">[&lt;/span>&lt;span style="color:#98c379">&amp;#34;a&amp;#34;&lt;/span>&lt;span style="color:#abb2bf">]&lt;/span> &lt;span style="color:#abb2bf">=&lt;/span> &lt;span style="color:#d19a66">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#aa89ea">fmt&lt;/span>&lt;span style="color:#abb2bf">.&lt;/span>&lt;span style="color:#00b1f7">Println&lt;/span>&lt;span style="color:#abb2bf">(&lt;/span>&lt;span style="color:#aa89ea">m&lt;/span>&lt;span style="color:#abb2bf">[&lt;/span>&lt;span style="color:#98c379">&amp;#34;a&amp;#34;&lt;/span>&lt;span style="color:#abb2bf">])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#abb2bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8a93a5;font-style:italic">//panic: assignment to entry in nil map&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查了一下原因，发现是通过 &lt;code>var m map[string]int&lt;/code> 得到的值是 nil, 不指向任何内存地址。需要通过 &lt;code>make&lt;/code> 方法才可以分配确定的内存地址。&lt;/p></description></item><item><title>Kafka 和 RabbitMQ 对比</title><link>https://yindongliang.com/posts/compare-kafka-and-rabbitmq/</link><pubDate>Sat, 11 Jul 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/compare-kafka-and-rabbitmq/</guid><description>&lt;p>消息队列中间件（Message Queue Middleware，简称 MQ）在后端领域扮演很重要的角色，但是笔者之前日常多止步于使用，对机制原理研究很少。之前用 Python 写 Web 服务的时候，用到 RabbitMQ 的情况比较多，可能是因为有一个基于 Python 的消息队列的封装库 Celery 非常好用。后来写 Go 服务的时候，接入了公司整体的技术架构，Kafka 又用的比较多。这里接针对两种消息中间件专门对比一下各自的底层机制，方便在业务场景中做决策。&lt;/p></description></item><item><title>Gin Web 框架中 Middleware 的实现原理</title><link>https://yindongliang.com/posts/gin-middleware/</link><pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/gin-middleware/</guid><description>&lt;p>Gin 和很多 Web 框架一样实现了 middleware（中间件）的功能，通过 Gin 提供的中间件，我们在业务逻辑处理每个请求之前进行一些通用的逻辑，比如身份校验、数据解密、签名认证、服务限流等功能。&lt;/p></description></item><item><title>Go 语言中 Goroutine 的并发数量控制</title><link>https://yindongliang.com/posts/go-concurrency/</link><pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/go-concurrency/</guid><description>&lt;p>虽然 Goroutine 号称占用的内存非常小，初始化只有几 K 大小，但是很多时候确实还是需要控制一台机器的 Goroutine 的并发数量，以进行业务上的可控并发场景的需要，或防止异常情况下的CPU、内存过载进而导致服务不可用的情况。&lt;/p></description></item><item><title>Gin Web 框架中 Validate 使用总结</title><link>https://yindongliang.com/posts/go-gin-validate/</link><pubDate>Sun, 07 Jun 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/go-gin-validate/</guid><description>&lt;p>在处理 HTTP 请求的时候，需要经常对请求的参数做 validate 验证，在 Django 框架里有 Serializer 里的 &lt;code>validate&lt;/code> 方法来做校验，现在在 Go 语言的 Gin 框架下，也有类似的实现。Gin 使用了 &lt;a href="https://github.com/go-playground/validator">go-playground/validator&lt;/a> 来做校验，下面主要介绍下使用方法。&lt;/p></description></item><item><title>Go 程序取消子 Goroutine 的几种方式</title><link>https://yindongliang.com/posts/a-few-ways-goroutine-cancel-child-goroutines/</link><pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/a-few-ways-goroutine-cancel-child-goroutines/</guid><description>&lt;p>Go 代码中如果有的 Goroutine 永远都不会退出，随着 Goroutine 的数量增长，内存泄露的风险也会变高。因此必须需要一种方法能够控制 Goroutine 的野蛮生长，在需要退出的场景下必须要主动退出。下面介绍几种方法来主动退出 Goroutine。&lt;/p></description></item><item><title>使用 Typora 来编辑你的 Hugo 博客</title><link>https://yindongliang.com/posts/use-typora-write-hugo-blog/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/use-typora-write-hugo-blog/</guid><description>&lt;p>最近 typroa 用的比较多，然后又想着继续维护在 github pages 的博客，觉得把 typora 编辑完的东西再复制到博客项目里很麻烦，于是开始了一番折腾。&lt;/p>
&lt;h2 id="目标是啥">目标是啥&lt;a class="anchor" href="#%e7%9b%ae%e6%a0%87%e6%98%af%e5%95%a5">#&lt;/a>&lt;/h2>
&lt;p>在 typora 写的笔记放在了 iCloud，然后可以一键同步到我的线上博客&lt;/p></description></item><item><title>Go 标准库中涉及 I/O 操作的几个包的区别</title><link>https://yindongliang.com/posts/difference-between-go-io-packages/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/difference-between-go-io-packages/</guid><description>&lt;p>工作中需要用 Go 读写一些 Excel 表等类型的文件，发现 Go 提供了很多关于 I/O 操作的包，比如 io、ioutil、bufio 等，于是在这里总结一下，主要目标是理清几个包之间在使用时如何选择。&lt;/p></description></item><item><title>Redis 的分布式锁使用注意</title><link>https://yindongliang.com/posts/redis-distribute-lock/</link><pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate><guid>https://yindongliang.com/posts/redis-distribute-lock/</guid><description>&lt;h2 id="为什么需要分布式锁">为什么需要分布式锁&lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81">#&lt;/a>&lt;/h2>
&lt;p>锁机制用于管理对共享资源的并发访问控制，当同一服务的多台机器间需要控制并发的时候，需要保证服务间在同一时间只能被一个线程访问。由于 Redis 的特点是单进程，并且具有高性能的特点，所以一般用 Redis 来做分布式锁。另外分布式锁还有以下几个特点：&lt;/p></description></item></channel></rss>